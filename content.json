{"meta":{"title":"realwds's blog","subtitle":"数学系的挨踢者","description":"精致的五官是心动的开始，迷人的气质是动情的深渊。","author":"Alejandro","url":"https://realwds.github.io/hexo-volantis-blog","root":"/hexo-volantis-blog/"},"pages":[{"title":"","date":"2021-06-07T08:45:14.462Z","updated":"2021-06-07T08:45:14.462Z","comments":true,"path":"mylists/index.html","permalink":"https://realwds.github.io/hexo-volantis-blog/mylists/index.html","excerpt":"","text":""},{"title":"","date":"2021-06-07T09:30:36.186Z","updated":"2021-06-07T09:30:36.186Z","comments":true,"path":"about/index.html","permalink":"https://realwds.github.io/hexo-volantis-blog/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"我的朋友们","date":"2021-06-07T09:31:16.883Z","updated":"2021-06-07T09:31:16.883Z","comments":true,"path":"friends/index.html","permalink":"https://realwds.github.io/hexo-volantis-blog/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2021-06-07T08:44:16.312Z","updated":"2021-06-07T08:44:16.312Z","comments":true,"path":"categories/index.html","permalink":"https://realwds.github.io/hexo-volantis-blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-06-07T08:44:23.038Z","updated":"2021-06-07T08:44:23.038Z","comments":true,"path":"tags/index.html","permalink":"https://realwds.github.io/hexo-volantis-blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS 常用知识点回顾","slug":"CSS 常用知识点回顾","date":"2021-05-19T04:01:06.000Z","updated":"2021-06-08T07:26:51.167Z","comments":true,"path":"posts/337220b2","link":"","permalink":"https://realwds.github.io/hexo-volantis-blog/posts/337220b2","excerpt":"","text":"隐藏元素 display: none; 会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden; 不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见。 display: none; 是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden; 是继承属性，子孙节点消失由于继承了hidden，通过设置 visibility: visible; 可以让子孙节点显式。 修改常规流中元素的 display 通常会造成文档重排。修改 visibility 属性只会造成本元素的重绘。 读屏器不会读取 display: none; 元素内容；会读取 visibility: hidden; 元素内容。 盒模型页面渲染时，dom 元素所采用的布局模型。可通过 box-sizing 进行设置。根据计算宽高的区域可分为： content-box (W3C 标准盒模型) border-box (IE 盒模型) padding-box margin-box (浏览器未实现) BFC块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 触发条件 根元素 position: absolute / fixed display: inline-block / table float 元素 ovevflow !== visible 规则 属于同一个 BFC 的两个相邻 Box 垂直排列 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外) BFC 的区域不会与 float 的元素区域重叠 计算 BFC 的高度时，浮动子元素也参与计算 文字层不会被浮动层覆盖，环绕于周围 应用 阻止 margin 重叠 可以包含浮动元素 —— 清除内部浮动 (清除浮动的原理是两个 div 都位于同一个 BFC 区域之中) 自适应两栏布局 可以阻止元素被浮动元素覆盖 居中布局水平居中 行内元素：text-align: center 块级元素：margin: 0 auto absolute + transform flex + justify-content: center 垂直居中 line-height: height absolute + transform flex + align-items: center table 水平垂直居中 absolute + transform flex + justify-content + align-items 选择器以及优先级 id 选择器（ # myid） 类选择器（.myclassname） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（ * ） 属性选择器（a[rel = “external”]） 伪类选择器（a:hover, li:nth-child） !important &gt; 行内样式 &gt; #id &gt; .class &gt; tag &gt; * &gt; 继承 &gt; 默认 选择器 从右往左 解析 弹性盒子中 flex: 0 1 auto 分别表示什么三个参数分别对应的是 flex-grow, flex-shrink 和 flex-basis，默认值为 0 1 auto。 flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。 link 与 @import 的区别 link 功能较多，可以定义 RSS，定义 Rel 等作用，而 @import 只能用于加载 css 当解析到 link 时，页面会同步加载所引的 css，而 @import 所引用的 css 会等到页面加载完才被加载 @import 需要 IE5 以上才能使用 link 可以使用 js 动态引入，@import 不行 伪类和伪元素CSS 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素都是用来修饰不在文档树中的部分 伪类伪类存在的意义是为了通过选择器找到那些不存在 DOM 树中的信息以及不能被常规 CSS 选择器获取到的信息 获取不存在与 DOM 树中的信息。比如 a 标签的 :link、visited 等，这些信息不存在与 DOM 树结构中，只能通过 CSS 选择器来获取； 获取不能被常规 CSS 选择器获取的信息。比如：要获取第一个子元素，我们无法用常规的 CSS 选择器获取，但可以通过 :first-child 来获取到。 伪元素伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过 :before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等 因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素 ::after和:after的区别在实际的开发工作中，我们会看到有人把伪元素写成 :after，这实际是 CSS2 与 CSS3 新旧标准的规定不同而导致的。 CSS2 中的伪元素使用1个冒号，在 CSS3 中，为了区分伪类和伪元素，规定伪元素使用2个冒号。所以，对于 CSS2 标准的老伪元素，比如 :first-line，:first-letter，:before，:after，写一个冒号浏览器也能识别，但对于 CSS3 标准的新伪元素，比如 ::selection，就必须写2个冒号了 CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容。 not(elem) 选择非 elem 元素的每个元素。 :enabled 控制表单控件的禁用状态。 :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://realwds.github.io/hexo-volantis-blog/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://realwds.github.io/hexo-volantis-blog/tags/css/"},{"name":"精选","slug":"精选","permalink":"https://realwds.github.io/hexo-volantis-blog/tags/%E7%B2%BE%E9%80%89/"},{"name":"知识点","slug":"知识点","permalink":"https://realwds.github.io/hexo-volantis-blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"JavaScript 常用知识点回顾","slug":"JavaScript 常用知识点回顾","date":"2021-05-19T03:43:04.000Z","updated":"2021-06-08T07:31:07.809Z","comments":true,"path":"posts/5b7188dc","link":"","permalink":"https://realwds.github.io/hexo-volantis-blog/posts/5b7188dc","excerpt":"","text":"内置类型 JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。 基本类型有六种：null，undefined，boolean，number，string，symbol。 其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754 标准实现，在使用中会遇到某些 Bug。NaN 也属于 number 类型，并且 NaN 不等于自身。 对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型。 12let a = 111 // 这只是字面量，不是 number 类型a.toString() // 使用时候才会转换为对象类型 对象（Object）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。 1234let a = &#123; name: &#x27;FE&#x27; &#125;let b = ab.name = &#x27;EF&#x27;console.log(a.name) // EF null 和 undefined 的区别null 是一个表示”无”的对象，转为数值时为0；undefined 是一个表示”无”的原始值，转为数值时为 NaN。 当声明的变量还未被初始化时，变量的默认值为 undefined。 null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 undefined 表示“缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： 变量被声明了，但没有赋值时，就等于 undefined。 调用函数时，应该提供的参数没有提供，该参数等于 undefined。 对象没有赋值的属性，该属性的值为 undefined。 函数没有返回值时，默认返回 undefined。 null 表示“没有对象”，即该处不应该有值。典型用法是： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 new 操作符具体干了什么 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 属性和方法被加入到 this 引用的对象中。 新创建的对象由 this 所引用，并且最后隐式的返回 this。 call、apply、bind 三者的异同点bind、apply、call 三者都可以用来改变 this 的指向, 下面分别对他们进行比较分析： apply 和 call 二者都是 Function 对象的方法，每个函数都能调用 二者的第一个参数都是你要指定的执行上下文。 apply 和 call 的区别是： call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。 123456789var a = &#123; name: &#x27;Cherry&#x27;, fn: function(a, b) &#123; console.log(a + b) &#125;,&#125;var b = a.fnb.apply(a, [1, 2]) // 3b.call(a, 4, 5, 6) // 15 我们常常使用的验证是否是数组（前提是 toString() 方法没有被重写过）： 123function isArray(obj) &#123; return Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;&#125; 我们发现 bind() 方法还需要调用一次；是由于 bind() 方法创建一个新的函数,我们必须手动去调用。 12345678var a = &#123; name: &#x27;Cherry&#x27;, fn: function(a, b) &#123; console.log(a + b) &#125;,&#125;var b = a.fnb.bind(a, 1, 2)() // 3 bind、apply、call 的共同和不同点： 三者都可以用来改变 this 的指向 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文，上下文就是指调用函数的那个对象。（点前的那个对象，没有就是全局 window） 三者都可以传参，但是 apply 是数组，而 call 是有顺序的传入 bind 是返回对应函数，便于稍后调用；apply、call 则是立即执行 跨域问题解决方式 通过 jsonp 跨域 跨域资源共享（CORS） nodejs 中间件代理跨域 nginx 反向代理中设置 proxy_cookie_domain 1. 通过 jsonp 跨域通常为了减轻 web 服务器的负载，我们把 js、css、img 等静态资源分离到另一台独立域名的服务器上，在 html 页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建 script，再请求一个带参网址实现跨域通信。 1234567891011var script = document.createElement(&#x27;script&#x27;);script.type = &#x27;text/javascript&#x27;;// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数script.src = &#x27;http://www.xxx.com:8080/login?user=admin&amp;callback=jsonCallback&#x27;;document.head.appendChild(script);// 回调执行函数function jsonCallback(res) &#123; alert(JSON.stringify(res));&#125; 2. 跨域资源共享（CORS）CORS 是一个 W3C 标准，全称是“跨域资源共享”（Cross-origin resource sharing）跨域资源共享 CORS 详解。看名字就知道这是处理跨域问题的标准做法。CORS 有两种请求，简单请求和非简单请求。 简单请求： 请求方法是 HEAD、GET 、POST 三种方法之一 HTTP 请求头的信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于 application/x-www-form-urlencoded、multipart/form-data、text/plain 复杂请求： 如果前端要带 cookie, 前端也需要单独设置 1234var xhr = new XMLHttpRequest();// 前端设置是否带cookiexhr.withCredentials = true;... 3. Nodejs 中间件代理跨域通过起一个代理服务器， 实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头 cookie 中域名,实现当前域下 cookie 的写入 在 vue 框架下实现跨域 利用 node + webpack + webpack-dev-server 代理接口跨域。在开发环境下，由于 vue 渲染服务和接口代理服务都是 webpack-dev-server 同一个，所以页面与代理接口之间不再跨域，无须设置 headers 跨域信息了。后台可以不做任何处理。 12345678910111213141516module.exports = &#123; entry: &#123;&#125;, module: &#123;&#125;, ... devServer: &#123; historyApiFallback: true, proxy: [&#123; context: &#x27;/login&#x27;, target: &#x27;http://xxx.com:8080&#x27;, // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: &#x27;xxx.com&#x27; // 可以为false，表示不修改 &#125;], noInfo: true &#125;&#125; 4. Nginx 反向代理中设置和使用 node 中间件跨域原理相似。前端和后端都不需要写额外的代码来处理， 只需要配置一下 Nginx 1234567server &#123; listen 80; server_name aa.com; location ^~ /api &#123; proxy_pass http://xxx.com; &#125;&#125; defer 和 async 的区别1&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，”立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 1&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt; 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 1&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt; 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 数据类型转换JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下: 转化规则 - 、* 、/ 、%：一律转换成数值后计算 +： 数字 + 字符串 = 字符串， 运算顺序是从左到右 数字 + 对象， 优先调用对象的 valueOf -&gt; toString 数字 + boolean/null -&gt; 数字 数字 + undefined -&gt; NaN [1].toString() === &#39;1&#39; &#123;&#125;.toString() === &#39;[object object]&#39; NaN !== NaN 、+undefined 为 NaN 在 JS 中类型转换只有三种情况，分别是： 转换为布尔值 转换为数字 转换为字符串 原始值 转换目标 结果 number 布尔值 除了 0、-0、NaN 都为 true string 布尔值 除了空字符串都为 true undefined、null 布尔值 false 引用类型 布尔值 true number 字符串 5 =&gt; ‘5’ Boolean、函数、Symbol 字符串 ‘true’ 数组 字符串 [1, 2] =&gt; ‘1, 2’ 对象 字符串 ‘[Object Object]’ string 数字 ‘1’ =&gt; 1, ‘a’ =&gt; NaN 数组 数字 空数组为0，存在一个元素且为数字转为数字，其他情况NaN null 数字 0 除了数组的引用类型 数字 NaN Symbol 数字 抛错","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://realwds.github.io/hexo-volantis-blog/categories/JavaScript/"}],"tags":[{"name":"精选","slug":"精选","permalink":"https://realwds.github.io/hexo-volantis-blog/tags/%E7%B2%BE%E9%80%89/"},{"name":"知识点","slug":"知识点","permalink":"https://realwds.github.io/hexo-volantis-blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"js","slug":"js","permalink":"https://realwds.github.io/hexo-volantis-blog/tags/js/"}]}],"categories":[{"name":"CSS","slug":"CSS","permalink":"https://realwds.github.io/hexo-volantis-blog/categories/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://realwds.github.io/hexo-volantis-blog/categories/JavaScript/"}],"tags":[{"name":"css","slug":"css","permalink":"https://realwds.github.io/hexo-volantis-blog/tags/css/"},{"name":"精选","slug":"精选","permalink":"https://realwds.github.io/hexo-volantis-blog/tags/%E7%B2%BE%E9%80%89/"},{"name":"知识点","slug":"知识点","permalink":"https://realwds.github.io/hexo-volantis-blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"js","slug":"js","permalink":"https://realwds.github.io/hexo-volantis-blog/tags/js/"}]}