<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>realwds&#39;s blog</title>
  
  <subtitle>数学系的挨踢者</subtitle>
  <link href="https://blog.realwds.com/atom.xml" rel="self"/>
  
  <link href="https://blog.realwds.com/"/>
  <updated>2021-06-08T07:26:51.167Z</updated>
  <id>https://blog.realwds.com/</id>
  
  <author>
    <name>Alejandro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS 常用知识点回顾</title>
    <link href="https://blog.realwds.com/posts/337220b2"/>
    <id>https://blog.realwds.com/posts/337220b2</id>
    <published>2021-05-19T04:01:06.000Z</published>
    <updated>2021-06-08T07:26:51.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h2><ul><li><code>display: none;</code> 会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden;</code> 不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见。</li><li><code>display: none;</code> 是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility: hidden;</code> 是继承属性，子孙节点消失由于继承了hidden，通过设置 <code>visibility: visible;</code> 可以让子孙节点显式。</li><li>修改常规流中元素的 <code>display</code> 通常会造成文档重排。修改 <code>visibility</code> 属性只会造成本元素的重绘。</li><li>读屏器不会读取 <code>display: none;</code> 元素内容；会读取 <code>visibility: hidden;</code> 元素内容。</li></ul><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>页面渲染时，<code>dom</code> 元素所采用的布局模型。可通过 <code>box-sizing</code> 进行设置。根据计算宽高的区域可分为：</p><ul><li><code>content-box</code> (W3C 标准盒模型)</li><li><code>border-box</code> (IE 盒模型)</li><li><code>padding-box</code></li><li><code>margin-box</code> (浏览器未实现)</li></ul><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>块级格式化上下文，是一个独立的渲染区域，让处于 <code>BFC</code> 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ul><li>根元素</li><li>position: absolute / fixed</li><li>display: inline-block / table</li><li>float 元素</li><li>ovevflow !== visible</li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>属于同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 垂直排列</li><li>属于同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 的 <code>margin</code> 会发生重叠</li><li><code>BFC</code> 中子元素的 <code>margin box</code> 的左边， 与包含块 (BFC) <code>border box</code> 的左边相接触 (子元素 <code>absolute</code> 除外)</li><li><code>BFC</code> 的区域不会与 <code>float</code> 的元素区域重叠</li><li>计算 <code>BFC</code> 的高度时，浮动子元素也参与计算</li><li>文字层不会被浮动层覆盖，环绕于周围</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>阻止 <code>margin</code> 重叠</li><li>可以包含浮动元素 —— 清除内部浮动 (清除浮动的原理是两个 <code>div</code> 都位于同一个 <code>BFC</code> 区域之中)</li><li>自适应两栏布局</li><li>可以阻止元素被浮动元素覆盖</li></ul><h2 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ul><li>行内元素：text-align: center</li><li>块级元素：margin: 0 auto</li><li>absolute + transform</li><li>flex + justify-content: center</li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li>line-height: height</li><li>absolute + transform</li><li>flex + align-items: center</li><li>table</li></ul><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><ul><li>absolute + transform</li><li>flex + justify-content + align-items</li></ul><h2 id="选择器以及优先级"><a href="#选择器以及优先级" class="headerlink" title="选择器以及优先级"></a>选择器以及优先级</h2><ul><li>id 选择器（ # myid）</li><li>类选择器（.myclassname）</li><li>标签选择器（div, h1, p）</li><li>相邻选择器（h1 + p）</li><li>子选择器（ul &gt; li）</li><li>后代选择器（li a）</li><li>通配符选择器（ * ）</li><li>属性选择器（a[rel = “external”]）</li><li>伪类选择器（a:hover, li:nth-child）</li><li>!important &gt; 行内样式 &gt; #id &gt; .class &gt; tag &gt; * &gt; 继承 &gt; 默认</li><li>选择器 从右往左 解析</li></ul><h2 id="弹性盒子中-flex-0-1-auto-分别表示什么"><a href="#弹性盒子中-flex-0-1-auto-分别表示什么" class="headerlink" title="弹性盒子中 flex: 0 1 auto 分别表示什么"></a>弹性盒子中 flex: 0 1 auto 分别表示什么</h2><p>三个参数分别对应的是 <code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>，默认值为 <code>0 1 auto</code>。</p><ul><li><code>flex-grow</code> 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li><code>flex-shrink</code> 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li><code>flex-basis</code> 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。</li></ul><h2 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="headerlink" title="link 与 @import 的区别"></a>link 与 @import 的区别</h2><ul><li>  <code>link</code> 功能较多，可以定义 <code>RSS</code>，定义 <code>Rel</code> 等作用，而 <code>@import</code> 只能用于加载 <code>css</code></li><li>  当解析到 <code>link</code> 时，页面会同步加载所引的 <code>css</code>，而 <code>@import</code> 所引用的 <code>css</code> 会等到页面加载完才被加载</li><li>  <code>@import</code> 需要 IE5 以上才能使用</li><li>  <code>link</code> 可以使用 <code>js</code> 动态引入，<code>@import</code> 不行</li></ul><h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><p><code>CSS</code> 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素都是用来修饰不在文档树中的部分</p><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>伪类存在的意义是为了通过选择器找到那些不存在 DOM 树中的信息以及不能被常规 CSS 选择器获取到的信息</p><ul><li>获取不存在与 DOM 树中的信息。比如 <code>a</code> 标签的 <code>:link</code>、<code>visited</code> 等，这些信息不存在与 DOM 树结构中，只能通过 CSS 选择器来获取；</li><li>获取不能被常规 CSS 选择器获取的信息。比如：要获取第一个子元素，我们无法用常规的 CSS 选择器获取，但可以通过 <code>:first-child</code> 来获取到。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/realwds/cdn@master/blog/false-class.81137d65.47ajvus48zs0.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/realwds/cdn@master/blog/false-class.81137d65.47ajvus48zs0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过 <code>:before</code> 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：<code>::before</code>，<code>::after</code>，<code>::first-line</code>，<code>::first-letter</code>，<code>::selection</code>、<code>::placeholder</code>等</p><p>因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素</p><h3 id="after和-after的区别"><a href="#after和-after的区别" class="headerlink" title="::after和:after的区别"></a><code>::after</code>和<code>:after</code>的区别</h3><p>在实际的开发工作中，我们会看到有人把伪元素写成 <code>:after</code>，这实际是 CSS2 与 CSS3 新旧标准的规定不同而导致的。 CSS2 中的伪元素使用1个冒号，在 CSS3 中，为了区分伪类和伪元素，规定伪元素使用2个冒号。所以，对于 CSS2 标准的老伪元素，比如 <code>:first-line</code>，<code>:first-letter</code>，<code>:before</code>，<code>:after</code>，写一个冒号浏览器也能识别，但对于 CSS3 标准的新伪元素，比如 <code>::selection</code>，就必须写2个冒号了</p><h3 id="CSS3新增伪类有那些？"><a href="#CSS3新增伪类有那些？" class="headerlink" title="CSS3新增伪类有那些？"></a>CSS3新增伪类有那些？</h3><ul><li><code>p:first-of-type</code> 选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:last-of-type</code> 选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:only-of-type</code> 选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:only-child</code> 选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:nth-child(2)</code> 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>:after</code> 在元素之前添加内容,也可以用来做清除浮动。</li><li><code>:before</code> 在元素之后添加内容。</li><li><code>not(elem)</code> 选择非 elem 元素的每个元素。</li><li><code>:enabled</code> 控制表单控件的禁用状态。</li><li><code>:disabled</code> 控制表单控件的禁用状态。</li><li><code>:checked</code> 单选框或复选框被选中。</li></ul>]]></content>
    
    
    <summary type="html">CSS 常用知识点回顾</summary>
    
    
    
    <category term="CSS" scheme="https://blog.realwds.com/categories/CSS/"/>
    
    
    <category term="css" scheme="https://blog.realwds.com/tags/css/"/>
    
    <category term="精选" scheme="https://blog.realwds.com/tags/%E7%B2%BE%E9%80%89/"/>
    
    <category term="知识点" scheme="https://blog.realwds.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 常用知识点回顾</title>
    <link href="https://blog.realwds.com/posts/5b7188dc"/>
    <id>https://blog.realwds.com/posts/5b7188dc</id>
    <published>2021-05-19T03:43:04.000Z</published>
    <updated>2021-06-08T07:31:07.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><ul><li><code>JS</code> 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。</li><li>基本类型有六种：<code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。</li><li>其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754 标准实现，在使用中会遇到某些 Bug。<code>NaN</code> 也属于 <code>number</code> 类型，并且 <code>NaN</code> 不等于自身。</li><li>对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">111</span> <span class="comment">// 这只是字面量，不是 number 类型</span></span><br><span class="line">a.toString() <span class="comment">// 使用时候才会转换为对象类型</span></span><br></pre></td></tr></table></figure><blockquote><p>对象（Object）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;FE&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">b.name = <span class="string">&#x27;EF&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">// EF</span></span><br></pre></td></tr></table></figure><h2 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h2><p><code>null</code> 是一个表示”无”的对象，转为数值时为0；<code>undefined</code> 是一个表示”无”的原始值，转为数值时为 NaN。</p><p>当声明的变量还未被初始化时，变量的默认值为 <code>undefined</code>。 <code>null</code> 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p><p><code>undefined</code> 表示“缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p><ul><li>变量被声明了，但没有赋值时，就等于 undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于 undefined。</li><li>对象没有赋值的属性，该属性的值为 undefined。</li><li>函数没有返回值时，默认返回 undefined。</li></ul><p><code>null</code> 表示“没有对象”，即该处不应该有值。典型用法是：</p><ul><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ul><h2 id="new-操作符具体干了什么"><a href="#new-操作符具体干了什么" class="headerlink" title="new 操作符具体干了什么"></a>new 操作符具体干了什么</h2><ul><li>创建一个空对象，并且 <code>this</code> 变量引用该对象，同时还继承了该函数的原型。</li><li>属性和方法被加入到 <code>this</code> 引用的对象中。</li><li>新创建的对象由 <code>this</code> 所引用，并且最后隐式的返回 <code>this</code>。</li></ul><h2 id="call、apply、bind-三者的异同点"><a href="#call、apply、bind-三者的异同点" class="headerlink" title="call、apply、bind 三者的异同点"></a>call、apply、bind 三者的异同点</h2><p><code>bind</code>、<code>apply</code>、<code>call</code> 三者都可以用来改变 <code>this</code> 的指向, 下面分别对他们进行比较分析：</p><p><code>apply</code> 和 <code>call</code> 二者都是 <code>Function</code> 对象的方法，每个函数都能调用 二者的第一个参数都是你要指定的执行上下文。</p><p><code>apply</code> 和 <code>call</code> 的区别是： <code>call</code> 方法接受的是若干个参数列表，而 <code>apply</code> 接收的是一个包含多个参数的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Cherry&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.fn</span><br><span class="line">b.apply(a, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span></span><br><span class="line">b.call(a, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>我们常常使用的验证是否是数组（前提是 <code>toString()</code> 方法没有被重写过）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&#x27;[object Array]&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 <code>bind()</code> 方法还需要调用一次；是由于 <code>bind()</code> 方法创建一个新的函数,我们必须手动去调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Cherry&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.fn</span><br><span class="line">b.bind(a, <span class="number">1</span>, <span class="number">2</span>)() <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p><code>bind</code>、<code>apply</code>、<code>call</code> 的共同和不同点：</p><ul><li>三者都可以用来改变 <code>this</code> 的指向</li><li>三者第一个参数都是 <code>this</code> 要指向的对象，也就是想指定的上下文，上下文就是指调用函数的那个对象。（点前的那个对象，没有就是全局 window）</li><li>三者都可以传参，但是 <code>apply</code> 是数组，而 <code>call</code> 是有顺序的传入</li><li><code>bind</code> 是返回对应函数，便于稍后调用；<code>apply</code>、<code>call</code> 则是立即执行</li></ul><h2 id="跨域问题解决方式"><a href="#跨域问题解决方式" class="headerlink" title="跨域问题解决方式"></a>跨域问题解决方式</h2><ul><li>通过 <code>jsonp</code> 跨域</li><li>跨域资源共享（<code>CORS</code>）</li><li><code>nodejs</code> 中间件代理跨域</li><li><code>nginx</code> 反向代理中设置 <code>proxy_cookie_domain</code></li></ul><h3 id="1-通过-jsonp-跨域"><a href="#1-通过-jsonp-跨域" class="headerlink" title="1. 通过 jsonp 跨域"></a>1. 通过 jsonp 跨域</h3><p>通常为了减轻 web 服务器的负载，我们把 js、css、img 等静态资源分离到另一台独立域名的服务器上，在 html 页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建 script，再请求一个带参网址实现跨域通信。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.type = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span><br><span class="line">script.src = <span class="string">&#x27;http://www.xxx.com:8080/login?user=admin&amp;callback=jsonCallback&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonCallback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-跨域资源共享（CORS）"><a href="#2-跨域资源共享（CORS）" class="headerlink" title="2. 跨域资源共享（CORS）"></a>2. 跨域资源共享（CORS）</h3><p><code>CORS</code> 是一个 W3C 标准，全称是“跨域资源共享”（<code>Cross-origin resource sharing</code>）跨域资源共享 <code>CORS</code> 详解。看名字就知道这是处理跨域问题的标准做法。<code>CORS</code> 有两种请求，简单请求和非简单请求。</p><p><strong>简单请求：</strong></p><ul><li>请求方法是 <code>HEAD</code>、<code>GET</code> 、<code>POST</code> 三种方法之一</li><li>HTTP 请求头的信息不超出以下几种字段：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于 application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></li></ul><p><strong>复杂请求：</strong></p><p>如果前端要带 <code>cookie</code>, 前端也需要单独设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="3-Nodejs-中间件代理跨域"><a href="#3-Nodejs-中间件代理跨域" class="headerlink" title="3. Nodejs 中间件代理跨域"></a>3. Nodejs 中间件代理跨域</h3><p>通过起一个代理服务器， 实现数据的转发，也可以通过设置 <code>cookieDomainRewrite</code> 参数修改响应头 <code>cookie</code> 中域名,实现当前域下 <code>cookie</code> 的写入</p><p>在 vue 框架下实现跨域</p><p>利用 <code>node + webpack + webpack-dev-server</code> 代理接口跨域。在开发环境下，由于 <code>vue</code> 渲染服务和接口代理服务都是 <code>webpack-dev-server</code> 同一个，所以页面与代理接口之间不再跨域，无须设置 <code>headers</code> 跨域信息了。后台可以不做任何处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;&#125;,</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">      <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">proxy</span>: [&#123;</span><br><span class="line">        <span class="attr">context</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://xxx.com:8080&#x27;</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">secure</span>: <span class="literal">false</span>,  <span class="comment">// 当代理某些https服务报错时用</span></span><br><span class="line">        <span class="attr">cookieDomainRewrite</span>: <span class="string">&#x27;xxx.com&#x27;</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">      &#125;],</span><br><span class="line">      <span class="attr">noInfo</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Nginx-反向代理中设置"><a href="#4-Nginx-反向代理中设置" class="headerlink" title="4. Nginx 反向代理中设置"></a>4. Nginx 反向代理中设置</h3><p>和使用 <code>node</code> 中间件跨域原理相似。前端和后端都不需要写额外的代码来处理， 只需要配置一下 <code>Nginx</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name aa.com;</span><br><span class="line">  location ^~ /api &#123;</span><br><span class="line">    proxy_pass http://xxx.com;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defer-和-async-的区别"><a href="#defer-和-async-的区别" class="headerlink" title="defer 和 async 的区别"></a>defer 和 async 的区别</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，”立即”指的是在渲染该 <code>script</code> 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有 <code>async</code>，加载和渲染后续文档元素的过程将和 <code>script.js</code> 的加载与执行并行进行（异步）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有 <code>defer</code>，加载后续文档元素的过程将和 <code>script.js</code> 的加载并行进行（异步），但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成。</p><p><img src="https://cdn.jsdelivr.net/gh/realwds/cdn@master/blog/script-defer-async.84113912.1idrxdvmec2o.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/realwds/cdn@master/blog/script-defer-async.84113912.1idrxdvmec2o.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><blockquote><p>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p></blockquote><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:</p><p>转化规则</p><ul><li><code>-</code> 、<code>*</code> 、<code>/</code> 、<code>%</code>：一律转换成数值后计算</li><li><code>+</code>：<ul><li>数字 + 字符串 = 字符串， 运算顺序是从左到右</li><li>数字 + 对象， 优先调用对象的 <code>valueOf -&gt; toString</code></li><li>数字 + <code>boolean/null</code> -&gt; 数字</li><li>数字 + <code>undefined -&gt; NaN</code></li></ul></li><li><code>[1].toString() === &#39;1&#39;</code></li><li><code>&#123;&#125;.toString() === &#39;[object object]&#39;</code></li><li><code>NaN !== NaN</code> 、<code>+undefined</code> 为 <code>NaN</code></li></ul><p>在 JS 中类型转换只有三种情况，分别是：</p><ul><li>转换为布尔值</li><li>转换为数字</li><li>转换为字符串</li></ul><table><thead><tr><th>原始值</th><th>转换目标</th><th>结果</th></tr></thead><tbody><tr><td>number</td><td>布尔值</td><td>除了 0、-0、NaN 都为 true</td></tr><tr><td>string</td><td>布尔值</td><td>除了空字符串都为 true</td></tr><tr><td>undefined、null</td><td>布尔值</td><td>false</td></tr><tr><td>引用类型</td><td>布尔值</td><td>true</td></tr><tr><td>number</td><td>字符串</td><td>5 =&gt; ‘5’</td></tr><tr><td>Boolean、函数、Symbol</td><td>字符串</td><td>‘true’</td></tr><tr><td>数组</td><td>字符串</td><td>[1, 2] =&gt; ‘1, 2’</td></tr><tr><td>对象</td><td>字符串</td><td>‘[Object Object]’</td></tr><tr><td>string</td><td>数字</td><td>‘1’ =&gt; 1, ‘a’ =&gt; NaN</td></tr><tr><td>数组</td><td>数字</td><td>空数组为0，存在一个元素且为数字转为数字，其他情况NaN</td></tr><tr><td>null</td><td>数字</td><td>0</td></tr><tr><td>除了数组的引用类型</td><td>数字</td><td>NaN</td></tr><tr><td>Symbol</td><td>数字</td><td>抛错</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">JavaScript 常用知识点回顾</summary>
    
    
    
    <category term="JavaScript" scheme="https://blog.realwds.com/categories/JavaScript/"/>
    
    
    <category term="精选" scheme="https://blog.realwds.com/tags/%E7%B2%BE%E9%80%89/"/>
    
    <category term="知识点" scheme="https://blog.realwds.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    <category term="js" scheme="https://blog.realwds.com/tags/js/"/>
    
  </entry>
  
</feed>
